#!/usr/bin/env python3

# .SHELLDOC
#
# BitShuffle command-line client. Supports encoding & decoding.
#
# .ENDOC

import os
import sys
import argparse
import base64
import bz2
import hashlib

stderr = sys.stderr
stdout = sys.stdout
stdin = sys.stdin

def encode_data(data, chunksize, compresslevel):
    """encode_data

    Compress the given data (which should be bytes), chunk it into chunksize
    sized chunks, base64 encode the chunks, and return the lot as a list of
    chunks, which are strings.

    :param data:
    :param compresslevel:
    """

    stderr.write("{} bytes -> ".format(len(data)))
    data = bz2.compress(data, compresslevel)
    stderr.write("{} bytes (compressed)".format(len(data)))

    chunks = []
    chunkptr = 0
    while True:
        chunk = data[chunkptr:chunkptr + chunksize - 1]
        chunkptr += chunksize

        chunks.append(base64.b64encode(chunk))

        if chunkptr > len(data):
            chunks.append(base64.b64encode(data[chunkptr:]))
            break

    chunksfinal = []
    for c in chunks:
        sys.stderr.write("chunk: '{}'\n".format(c))
        if len(c) > 0:
            chunksfinal.append(c)

    return chunksfinal

def encode_packet(data, filename, checksum, seqnum, seqmax):
    """encode_packet

    Take an already encoded data string and encode it to a BitShuffle data
    packet.

    :param data:
    """

    msg = "This is a BitShuffle encoded file, download BitShuffle from https://github.com/charlesdaniels/bitshuffle"
    compatlevel = "1"
    encoding = "base64"
    compression = "bz2"
    data = data.decode(encoding="ascii")

    fmt = "((<<{}|{}|{}|{}|{}|{}|{}|{}|{}>>))"
    packet = fmt.format(msg, compatlevel, encoding, compression, seqnum, seqmax, filename, checksum, data)
    return packet

def encode_file(fhandle, chunksize, compresslevel, filename):
    """encode_file

    Encode the file from fhandle and return a list of strings containing
    BitShuffle data packets.

    :param fhandle:
    """

    data = fhandle.read()
    checksum = hashlib.sha1(data).hexdigest()
    chunks = encode_data(data, chunksize, compresslevel)
    seqmax = len(chunks) - 1
    seqnum = 0
    for c in chunks:
        stderr.write("packet: {}\n".format(encode_packet(c, filename, checksum, seqnum, seqmax)))
        seqnum += 1



def main():
    have_term = stdin.isatty()

    parser = argparse.ArgumentParser(description="")

    parser.add_argument("--input", "-i", default="/dev/stdin",
                            help="Input file. Default is stdin.")
    parser.add_argument("--output", "-o", default="/dev/stdout",
                            help="Output file. Default is stdout.")

    parser.add_argument("--filename", "-f", default=None,
                            help="Set filename to use when encoding explicitly")

    iochoice = parser.add_mutually_exclusive_group(required=True)

    iochoice.add_argument("--encode", "-e", action="store_true",
                            help="Generate a BitShuffle data packet from " +
                            "the input file")

    iochoice.add_argument("--decode", "-d", "-D", action="store_true",
                            help="Extract a BitShuffle data packet.")

    parser.add_argument("--chunksize", "-c", type=int, default=32,
                            help="Chunk size in bytes")

    parser.add_argument("--compresslevel", '-m', type=int, default=1,
                            help="bz2 compression level when encoding")

    args = parser.parse_args()

    if args.filename is None:
        args.filename = os.path.basename(args.input)

    if args.encode:
        with open(args.input, 'rb') as f:
            encode_file(f, args.chunksize, args.compresslevel, args.filename)





if __name__ == "__main__":
	main()
